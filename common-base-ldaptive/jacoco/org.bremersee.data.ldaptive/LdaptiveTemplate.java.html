<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LdaptiveTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">common-base-ldaptive</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.data.ldaptive</a> &gt; <span class="el_source">LdaptiveTemplate.java</span></div><h1>LdaptiveTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.data.ldaptive;

import java.util.Collection;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;
import javax.validation.constraints.NotNull;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.bremersee.exception.ServiceException;
import org.ldaptive.AddOperation;
import org.ldaptive.AddRequest;
import org.ldaptive.AttributeModification;
import org.ldaptive.Connection;
import org.ldaptive.ConnectionFactory;
import org.ldaptive.DeleteOperation;
import org.ldaptive.DeleteRequest;
import org.ldaptive.LdapAttribute;
import org.ldaptive.LdapEntry;
import org.ldaptive.LdapException;
import org.ldaptive.ModifyOperation;
import org.ldaptive.ModifyRequest;
import org.ldaptive.ResultCode;
import org.ldaptive.SearchOperation;
import org.ldaptive.SearchRequest;
import org.springframework.http.HttpStatus;
import org.springframework.util.Assert;

/**
 * The template for executing ldap operations.
 *
 * @author Christian Bremer
 */
<span class="fc" id="L51">@Slf4j</span>
@SuppressWarnings(&quot;WeakerAccess&quot;)
public class LdaptiveTemplate implements LdaptiveOperations {

  private final ConnectionFactory connectionFactory;

  /**
   * Instantiates a new ldap template.
   *
   * @param connectionFactory the connection factory
   */
<span class="fc" id="L62">  public LdaptiveTemplate(final ConnectionFactory connectionFactory) {</span>
<span class="fc" id="L63">    Assert.notNull(connectionFactory, &quot;Connection factory must not be null.&quot;);</span>
<span class="fc" id="L64">    this.connectionFactory = connectionFactory;</span>
<span class="fc" id="L65">  }</span>

  private Connection getConnection() throws LdapException {
<span class="fc" id="L68">    final Connection connection = this.connectionFactory.getConnection();</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">    if (!connection.isOpen()) {</span>
<span class="fc" id="L70">      connection.open();</span>
    }
<span class="fc" id="L72">    return connection;</span>
  }

  /**
   * Close the given context and ignore any thrown exception. This is useful for typical finally
   * blocks in manual ldap statements.
   *
   * @param connection the ldap connection to close
   */
  private void closeConnection(final Connection connection) {
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">    if (connection != null &amp;&amp; connection.isOpen()) {</span>
      try {
<span class="fc" id="L84">        connection.close();</span>
<span class="nc" id="L85">      } catch (final Exception ex) {</span>
<span class="nc" id="L86">        log.warn(&quot;Closing ldap connection failed.&quot;, ex);</span>
<span class="fc" id="L87">      }</span>
    }
<span class="fc" id="L89">  }</span>

  @Override
  public &lt;T&gt; T execute(final LdaptiveConnectionCallback&lt;T&gt; callback) {
<span class="fc" id="L93">    Connection connection = null;</span>
    try {
<span class="fc" id="L95">      connection = getConnection();</span>
<span class="fc" id="L96">      return callback.doWithConnection(connection);</span>
<span class="nc" id="L97">    } catch (final LdapRuntimeException e) {</span>
<span class="nc" id="L98">      final ServiceException serviceException = new ServiceException(</span>
          HttpStatus.INTERNAL_SERVER_ERROR,
          &quot;org.bremersee:base-common-ldaptive:8150d733-cfb2-46a9-94f6-4f3395e7cecf&quot;,
<span class="nc" id="L101">          e.getLdapException());</span>
<span class="nc" id="L102">      log.error(&quot;Executing ldap operation failed.&quot;, serviceException);</span>
<span class="nc" id="L103">      throw serviceException;</span>
<span class="nc" id="L104">    } catch (final LdapException e) {</span>
<span class="nc" id="L105">      final ServiceException serviceException = new ServiceException(</span>
          HttpStatus.INTERNAL_SERVER_ERROR,
          &quot;org.bremersee:base-common-ldaptive:af8cb1fc-f9c2-4592-8bd6-de59c6f2a8e6&quot;,
          e);
<span class="nc" id="L109">      log.error(&quot;Executing ldap operation failed.&quot;, serviceException);</span>
<span class="nc" id="L110">      throw serviceException;</span>
    } finally {
<span class="fc" id="L112">      closeConnection(connection);</span>
    }
  }

  /**
   * Execute the given add request.
   *
   * @param addRequest the add request
   */
  public void add(@NotNull final AddRequest addRequest) {
<span class="fc" id="L122">    execute(connection -&gt; new AddOperation(connection).execute(addRequest));</span>
<span class="fc" id="L123">  }</span>

  /**
   * Execute the given modify request.
   *
   * @param modifyRequest the modify request
   */
  public void modify(@NotNull final ModifyRequest modifyRequest) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">    if (modifyRequest.getAttributeModifications() != null</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        &amp;&amp; modifyRequest.getAttributeModifications().length &gt; 0) {</span>
<span class="fc" id="L133">      execute(connection -&gt; new ModifyOperation(connection).execute(modifyRequest));</span>
    }
<span class="fc" id="L135">  }</span>

  /**
   * Find one ldap entry.
   *
   * @param searchRequest the search request
   * @return the ldap entry
   */
  public Optional&lt;LdapEntry&gt; findOne(
      @NotNull final SearchRequest searchRequest) {

<span class="fc" id="L146">    return Optional.ofNullable(</span>
<span class="fc" id="L147">        execute(connection -&gt; new SearchOperation(connection)</span>
<span class="fc" id="L148">            .execute(searchRequest)</span>
<span class="fc" id="L149">            .getResult()</span>
<span class="fc" id="L150">            .getEntry()));</span>
  }

  /**
   * Find one domain object.
   *
   * @param &lt;T&gt;           the type of the mapped domain object
   * @param searchRequest the search request
   * @param entryMapper   the entry mapper that maps a ldap entry into the domain object
   * @return the domain object
   */
  public &lt;T&gt; Optional&lt;T&gt; findOne(
      @NotNull final SearchRequest searchRequest,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {

<span class="fc" id="L165">    return Optional.ofNullable(</span>
<span class="fc" id="L166">        execute(connection -&gt; entryMapper</span>
<span class="fc" id="L167">            .map(new SearchOperation(connection)</span>
<span class="fc" id="L168">                .execute(searchRequest)</span>
<span class="fc" id="L169">                .getResult()</span>
<span class="fc" id="L170">                .getEntry())));</span>
  }

  /**
   * Find all ldap entries.
   *
   * @param searchRequest the search request
   * @return the ldap entries
   */
  public Collection&lt;LdapEntry&gt; findAll(
      @NotNull final SearchRequest searchRequest) {

<span class="fc" id="L182">    return execute(connection -&gt; new SearchOperation(connection)</span>
<span class="fc" id="L183">        .execute(searchRequest)</span>
<span class="fc" id="L184">        .getResult()</span>
<span class="fc" id="L185">        .getEntries());</span>
  }

  /**
   * Find domain objects.
   *
   * @param &lt;T&gt;           the type of the domain objects
   * @param searchRequest the search request
   * @param entryMapper   the entry mapper that maps a ldap entry into the domain object
   * @return the stream of found domain objects
   */
  public &lt;T&gt; Stream&lt;T&gt; findAll(
      @NotNull final SearchRequest searchRequest,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {

<span class="fc" id="L200">    return execute(connection -&gt; new SearchOperation(connection)</span>
<span class="fc" id="L201">        .execute(searchRequest)</span>
<span class="fc" id="L202">        .getResult()</span>
<span class="fc" id="L203">        .getEntries()</span>
<span class="fc" id="L204">        .stream()</span>
<span class="fc" id="L205">        .map(entryMapper::map))</span>
<span class="fc" id="L206">        .filter(Objects::nonNull);</span>
  }

  /**
   * Check whether a domain object exists or not.
   *
   * @param &lt;T&gt;          the type of the domain object
   * @param domainObject the domain object
   * @param entryMapper  the entry mapper that maps a ldap entry into the domain object
   * @return {@code true} if the domain object exists, otherwise {@code false}
   */
  public &lt;T&gt; boolean exists(
      @NotNull final T domainObject,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L220">    return execute(connection -&gt; {</span>
      try {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        return entryMapper.map(new SearchOperation(connection)</span>
<span class="fc" id="L223">            .execute(SearchRequest.newObjectScopeSearchRequest(entryMapper.mapDn(domainObject)))</span>
<span class="fc" id="L224">            .getResult()</span>
<span class="fc" id="L225">            .getEntry()) != null;</span>

<span class="fc" id="L227">      } catch (LdapException e) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (ResultCode.NO_SUCH_OBJECT == e.getResultCode()) {</span>
<span class="fc" id="L229">          return false;</span>
        }
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (e.getCause() instanceof javax.naming.NameNotFoundException) {</span>
<span class="nc" id="L232">          return false;</span>
        }
<span class="nc" id="L234">        throw e;</span>
      }
    });
  }

  /**
   * Save domain object.
   *
   * @param &lt;T&gt;          the type of the domain object
   * @param domainObject the domain object
   * @param entryMapper  the entry mapper that maps a ldap entry into the domain object
   * @return the saved domain object
   */
  public &lt;T&gt; T save(
      @NotNull final T domainObject,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L250">    return execute(connection -&gt; save(domainObject, entryMapper, connection));</span>
  }

  private &lt;T&gt; T save(
      final T domainObject,
      final LdaptiveEntryMapper&lt;T&gt; entryMapper,
      final Connection connection) throws LdapRuntimeException {

    try {
      final LdapEntry destination;
<span class="fc" id="L260">      final String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">      if (exists(domainObject, entryMapper)) {</span>
<span class="fc" id="L262">        destination = new SearchOperation(connection)</span>
<span class="fc" id="L263">            .execute(SearchRequest.newObjectScopeSearchRequest(dn))</span>
<span class="fc" id="L264">            .getResult()</span>
<span class="fc" id="L265">            .getEntry();</span>
<span class="fc" id="L266">        final AttributeModification[] modifications = entryMapper</span>
<span class="fc" id="L267">            .mapAndComputeModifications(domainObject, destination);</span>
<span class="pc bpc" id="L268" title="2 of 4 branches missed.">        if (modifications != null &amp;&amp; modifications.length &gt; 0) {</span>
<span class="fc" id="L269">          new ModifyOperation(connection)</span>
<span class="fc" id="L270">              .execute(new ModifyRequest(dn, modifications));</span>
        }
<span class="fc" id="L272">      } else {</span>
<span class="pc bpc" id="L273" title="2 of 4 branches missed.">        if (entryMapper.getObjectClasses() == null || entryMapper.getObjectClasses().length == 0) {</span>
<span class="nc" id="L274">          final ServiceException se = ServiceException.internalServerError(</span>
              &quot;Object classes must be specified to save a new ldap entry.&quot;,
              &quot;org.bremersee:common-base-ldaptive:d7aa5699-fd2e-45df-a863-97960e8095b8&quot;);
<span class="nc" id="L277">          log.error(&quot;Saving domain object failed.&quot;, se);</span>
<span class="nc" id="L278">          throw se;</span>
        }
<span class="fc" id="L280">        destination = new LdapEntry();</span>
<span class="fc" id="L281">        entryMapper.map(domainObject, destination);</span>
<span class="fc" id="L282">        destination.setDn(dn);</span>
<span class="fc" id="L283">        destination.addAttribute(new LdapAttribute(</span>
            &quot;objectclass&quot;,
<span class="fc" id="L285">            entryMapper.getObjectClasses()));</span>
<span class="fc" id="L286">        new AddOperation(connection)</span>
<span class="fc" id="L287">            .execute(new AddRequest(dn, destination.getAttributes()));</span>

      }
<span class="fc" id="L290">      return entryMapper.map(destination);</span>

<span class="nc" id="L292">    } catch (LdapException e) {</span>
<span class="nc" id="L293">      throw new LdapRuntimeException(e);</span>
    }
  }

  /**
   * Save all domain objects.
   *
   * @param &lt;T&gt;          the type of the domain objects
   * @param domainModels the domain objects
   * @param entryMapper  the entry mapper that maps a ldap entry into the domain object
   * @return the stream of saved domain objects
   */
  public &lt;T&gt; Stream&lt;T&gt; saveAll(
      final Collection&lt;T&gt; domainModels,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="pc bpc" id="L308" title="2 of 4 branches missed.">    if (domainModels == null || domainModels.isEmpty()) {</span>
<span class="nc" id="L309">      return Stream.empty();</span>
    }
<span class="fc" id="L311">    return domainModels.stream()</span>
<span class="fc" id="L312">        .filter(Objects::nonNull)</span>
<span class="fc" id="L313">        .map(domainModel -&gt; save(domainModel, entryMapper));</span>
  }

  /**
   * Execute the given delete request.
   *
   * @param deleteRequest the delete request
   */
  public void delete(@NotNull final DeleteRequest deleteRequest) {
<span class="fc" id="L322">    execute((LdaptiveConnectionCallbackWithoutResult) connection -&gt; new DeleteOperation(connection)</span>
<span class="fc" id="L323">        .execute(deleteRequest));</span>
<span class="fc" id="L324">  }</span>

  /**
   * Delete domain object.
   *
   * @param &lt;T&gt;          the type of the domain object
   * @param domainObject the domain object
   * @param entryMapper  the entry mapper that maps a ldap entry into the domain object
   */
  public &lt;T&gt; void delete(
      @NotNull final T domainObject,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L336">    execute(</span>
<span class="fc" id="L337">        (LdaptiveConnectionCallbackWithoutResult) connection -&gt; delete(</span>
            domainObject, entryMapper, connection));
<span class="fc" id="L339">  }</span>

  private &lt;T&gt; void delete(
      final T domainModel,
      final LdaptiveEntryMapper&lt;T&gt; entryMapper,
      final Connection connection) throws LdapRuntimeException {

    try {
<span class="fc" id="L347">      new DeleteOperation(connection).execute(new DeleteRequest(entryMapper.mapDn(domainModel)));</span>

<span class="nc" id="L349">    } catch (LdapException e) {</span>
<span class="nc" id="L350">      throw new LdapRuntimeException(e);</span>
<span class="fc" id="L351">    }</span>
<span class="fc" id="L352">  }</span>

  /**
   * Delete all domain objects.
   *
   * @param &lt;T&gt;           the type of the domain objects
   * @param domainObjects the domain objects
   * @param entryMapper   the entry mapper that maps a ldap entry into the domain object
   */
  public &lt;T&gt; void deleteAll(
      final Collection&lt;T&gt; domainObjects,
      @NotNull final LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">    if (domainObjects != null) {</span>
<span class="fc" id="L365">      execute((LdaptiveConnectionCallbackWithoutResult) connection -&gt; {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (T domainModel : domainObjects) {</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">          if (domainModel != null) {</span>
<span class="fc" id="L368">            delete(domainModel, entryMapper, connection);</span>
          }
<span class="fc" id="L370">        }</span>
<span class="fc" id="L371">      });</span>
    }
<span class="fc" id="L373">  }</span>

  private static class LdapRuntimeException extends RuntimeException {

<span class="nc" id="L377">    @Getter(AccessLevel.PACKAGE)</span>
    private LdapException ldapException;

    /**
     * Instantiates a new Ldap runtime exception.
     *
     * @param ldapException the ldap exception
     */
    LdapRuntimeException(LdapException ldapException) {
<span class="nc" id="L386">      super(ldapException);</span>
<span class="nc" id="L387">      this.ldapException = ldapException;</span>
<span class="nc" id="L388">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>